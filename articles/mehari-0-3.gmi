---
title: "Mehari 0.3"
date: 2023-08-10
authors:
  - Tim
description: La nouvelle mise-Ã -jour Ã©vÃ¨nement
tags:
- devlog
- ocaml
- mehari
---

Mehari 0.3 est sorti et aujourdâ€™hui nous allons discuter de la prochaine versionÂ : Mehari 0.4 (nom de code: prostate lovers)

Pour ceux qui ont cliquÃ© pour la version 0.3, le changelog complet est disponible ci-dessousÂ :

=> https://github.com/Psi-Prod/Mehari/releases/tag/0.3

Nâ€™hÃ©sitez pas Ã  faire vos remarques sur lâ€™API de Mehari en commentaire.

## Dans lâ€™assimilation parfaite

Pondre une API bien lissÃ©e est probablement ce que je prÃ©fÃ¨re faire en programmation (câ€™est notamment pour cette raison que jâ€™aime OCaml). Pour rendre dÃ©pendant des utilisateurs de ma seule volontÃ© et percer dans le OCaml jeu, il vaut mieux Ã©crire des bibliothÃ¨ques aussi composables que possible. Si le meilleur des pythonista se mettait Ã  Ã©crire une bibliothÃ¨que OCaml, il produirait assurÃ©ment quelque chose de convenable mais pas trÃ¨s agrÃ©able Ã  utiliser. Et câ€™est bien normal car il ne connaÃ®t ni les idiomes du langage, ni son Ã©cosystÃ¨me.

Venons-en au point, je nâ€™aime pas trop la faÃ§on dont les paramÃ¨tres de route sont gÃ©rÃ©s dans Mehari. Je mâ€™expliqueÂ :

```ocaml
let my_route =
  Mehari_lwt_unix.route "/echo/(.*)" ~regex:true (fun req ->
    Mehari.param req 1 |> Mehari.respond_text);
```

Ici, on dÃ©finit une route qui match tous les chemins qui commencent par `echo` et on renvoie le reste du chemin en utilisant `Mehari.param`.

Normalement, un truc a dÃ» vous piquer les yeux. Les regex sont Ã©crites en clair au lieu dâ€™utiliser un DSL pur OCaml typesafeÂ ! Et oui, il existe une super librairie â€“ sobrement nommÃ© `ocaml-re` (ğŸ—¿) â€“ qui permet dâ€™Ã©crire des regex de maniÃ¨re encore plus incomprÃ©hensibleÂ :

```ocaml
Re.(seq [ str "foo="; group (rep1 any) ]) <=> "foo=(.+)
```

=> https://github.com/ocaml/ocaml-re

On va donc remplacer le paramÃ¨tre labellisÃ© boolÃ©en `regex` par quelque chose de plus puissant pour choisir si lâ€™on souhaiteÂ :

* Fournir un `Re.t`Â ;
* Donner une route telle quelle sous forme de stringÂ ;
* Ã‰crire la regex en clair pour laisser les UNIX glob guys faire leur merdier.

Pour ce faire, deux options sâ€™offrent Ã  nousÂ :

* un GADTÂ : câ€™est stylÃ© et Ã§a permet de faire varier le type de la route en fonction du paramÃ¨tre donnÃ©Â ;
* la simplicitÃ©Â : plusieurs fonctions sÃ©parÃ©es (`route_regex`, `route`â€¦).

Utiliser un GADT signifierait devoir prÃ©ciser un paramÃ¨tre labellisÃ© pour chaque type de route, mÃªme lorsquâ€™on veut gÃ©rer une route triviale comme `/articles`, ce qui nâ€™est pas le cas actuellement dans Mehari. En effet, placer un constructeur dâ€™un GADT en tant quâ€™argument par dÃ©faut conduit Ã  fixer le type de ce dernier et interdit logiquement dâ€™utiliser des constructeurs dâ€™un type diffÃ©rentÂ :

```ocaml
type _ t = Int : int t | String : string t

let print (type a) ?(typ=Int) (x : a) = â€¦

let _ = print ~typ:String ""
                   ^^^^^^^^^
Error: This expression has type string t but an expression was expected of type
         int t
       Type string is not compatible with type int
```

> Si vous Ãªtes intÃ©ressÃ© par les GADT, jâ€™en ai dÃ©jÃ  parlÃ© moins briÃ¨vement dans cet articleÂ :
=> /articles/gadt-mehari.gmi

### Que faire

Dans les deux cas prÃ©sentÃ©s, ce serait un breaking change. Mais qui utilise Mehari pour faire tourner son serveur Gemini, sÃ©rieusementÂ ?

### Explication du design

Maintenant que le sujet est sur la table, je voulais mâ€™expliquer concernant le choix de supporter directement des regex plutÃ´t que dâ€™imposer notre propre systÃ¨me comme Dream le fait. Dâ€™un cÃ´tÃ©, Dream est plus lisible avec ses paramÃ¨tres nommÃ©s (`/foo/:bar`) mais dâ€™un autre cÃ´tÃ©, les expressions rÃ©guliÃ¨res sont plus puissantes, bien que plus Â«Â austÃ¨resÂ Â». Ã€ cela sâ€™ajoute un argument non nÃ©gligeableÂ : on nâ€™avait pas envie de se faire chier.

## Le cas de Mehari.param

En bidouillant un peu, je me suis aperÃ§u que la sÃ©mantique de Mehari.param est assez dÃ©plorable. En effet, cette fonction lÃ¨ve la mÃªme exception si lâ€™index est nÃ©gatif et si la paramÃ¨tre demandÃ© nâ€™est pas prÃ©sent dans la route. Ci-dessous un extrait de la docÂ :

> Mehari.param req n retrieves the n-th path parameter of req.
> Raise Invalid_argument if n is not a positive integer
> Raise Invalid_argument if path does not contain any parameters in which case the program is buggy.

Câ€™est donc sÃ©mantiquement impossible de distinguer une mauvaise utilisation de la fonction dâ€™une erreur de programmation, mÃªme en matchant sur le string contenu dans le constructeur `Invalid_argument`Â !

```ocaml
try Mehari.param req 1 with Invalid_argument msg when String.starts_with ~prefix:"xxx" -> raise "JE SUIS COMPLÃˆTEMENT FOU ğŸ˜¹"
```

On va donc prochainement lever `Not_found` lorsque la route ne contiendra aucun paramÃ¨tre rÃ©cupÃ©rable. Enfin on va peut-Ãªtre ajouter une fonction Ã©quivalente qui renverra soit un `string option` en levant `Invalid_argument`, soit un `(string, [ `NotFound |Â `NegativeInteger]) result`. Je ne sais pas encore quelle signature est la mieux, dites-moi.

## Formater les esprits

AprÃ¨s mâ€™avoir laissÃ© pour le moins perplexe pendant longtemps, jâ€™ai dÃ©couvert que le module Format Ã©tait une fesserie. Je me suis ainsi convaincu quâ€™utiliser cette machinerie dans la fonction `Gemtext.to_string` pouvait potentiellement Ãªtre une bonne idÃ©e.

Je me suis heureusement rendu compte quâ€™utiliser Format a la fÃ¢cheuse tendance de ne plus faire de la fonction `Gemtext.of_string` une bijection rÃ©ciproque de `Gemtext.to_string` (car Format implÃ©mente le soft-wrap des lignes trop longues).

Pour me pardonner de mon impertinence, voici une recette pour obtenir un rendu Gemtext lisible qui rend hommage au beau, au juste et au vraiÂ :

```ocaml
let pp_line ppf =
  let open Format in
  function
  | Text t -> pp_print_text ppf t
  | Link { url; name } ->
      fprintf ppf "@[<hov 2>â‡’ %s%a@]" url (pp_print_option (fun ppf ->
        fprintf ppf "@ %a" pp_print_text)) name
  | Preformat { alt; text } ->
      fprintf ppf "@[<v>%a@ %s@]" (pp_print_option pp_print_text) alt text
  | Heading (h, t) ->
    let hchar = match h with `H1 -> "â… " | `H2 -> "â…¡" | `H3 -> "â…¢" in
    fprintf ppf "@[<hov 2>%s %a@]" hchar pp_print_text t
  | ListItem t ->
    fprintf ppf "@[<hov 2>â€“ %a@]" pp_print_text t
  | Quote t ->
    let out_funs = Format.pp_get_formatter_out_functions ppf () in
    pp_set_formatter_out_functions ppf { out_funs with out_indent = (fun _ -> fprintf ppf "â–ˆ ")};
    fprintf ppf "@[<hov 0>â–ˆ %a@]" pp_print_text t;
    Format.pp_set_formatter_out_functions ppf out_funs

let pp = Format.pp_print_list ~pp_sep:Format.pp_force_newline pp_line

let gemtext =
  Mehari.Gemtext.[
    heading `H1 "Salut la compagnie";
    newline;
    link "https://heyplzlookat.me/" ~name:"Un super site";
    newline;
    heading `H2 "Passions";
    newline;
    text "Liste des passionsÂ :";
    list_item "le langage de prog OCaml";
    list_item "Marx";
    newline;
    quote "De trÃ¨s bonnes passions"
  ]

let () =
  Format.set_margin 20; (* Max 20 caractÃ¨res par ligne *)
  Format.printf "%a%!" pp gemtext
```

ImprÃ©gnez-vous maintenant dâ€™esthÃ©tique, misÃ©rables misomusesÂ :

```Sortie du programme ci-dessus
â…  Salut la
  compagnie

â‡’ https://heyplzlookat.me/
  Un super site

â…¡ Passions

Liste des
passionsÂ :
â€“ le langage de
  prog OCaml
â€“ Marx

â–ˆ De trÃ¨s bonnes
â–ˆ passions
```

## En vrac

### Mehari_mirage.static

Pour encore mieux intÃ©grer mehari-mirage, jâ€™aimerais bien ajouter une fonction pour servir statiquement des fichiers depuis une expression de type `Mirage_kv.RO`.

### Un paquet Gemtext

Il faudrait que lâ€™on factorise le module Gemtext de Mehari dans un paquet tierce car on lâ€™utilise Ã©galement dans Razzia, notre client Gemini secret non publiÃ© sur Opam en raison du manque de motivation pour Ã©crire sa documentation (mais qui reste malgrÃ© tout utilisable). De plus, cela nous permettrait de pouvoir tester le parser convenablement.

=> https://github.com/Psi-Prod/Razzia

### Dernier recourt

En y repensant, je me disais quâ€™il faudrait pouvoir personnaliser le comportement en cas de not found avec un handler mÃªme si câ€™est techniquement rÃ©alisable avec ce hackÂ :

```ocaml
Mehari_lwt_unix.router [
  â€¦;
  Mehari_lwt_unix.route "/(.*)" ~regex:true (fun _ ->
    Mehari.response not_found "not found !")
]
```
